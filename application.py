import pandas as pd
import tensorflow as tf
from sklearn.model_selection import train_test_split
import csv
from flask import Flask, render_template, request, redirect, url_for, flash

app = Flask(__name__)
app.secret_key = 'random string'


# The route() function of the Flask class is a decorator, which tells the application which URL should call the associated function.
@app.route('/')
def index():
    return render_template('index2.html')


@app.route('/upload1', methods=['POST'])
def upload():
    # Attributes name in csv file
    columns = ['Age', 'BSfast', 'BSpp', 'PlasmaR', 'PlasmaF', 'HbA1c', 'Type', 'Class']

    # Read CSV file
    diabetes = pd.read_csv("Diabetestype.csv", skipinitialspace=True, skiprows=1, names=columns, nrows=1010)

    # Feature columns
    FEATURES = ['Age', 'BSfast', 'BSpp', 'PlasmaR', 'PlasmaF', 'HbA1c']
    feat_cols = [tf.feature_column.numeric_column(k) for k in FEATURES]

    # Dropping the outcome column in diabetes
    x_data = diabetes.drop('Class', axis=1)
    x_data = diabetes.drop('Type', axis=1)

    # Label column
    labels = diabetes['Class']
    print(x_data)

    # preparing features and labels for a train test split
    X_train, X_test, y_train, y_test = train_test_split(x_data, labels, test_size=0.30, random_state=101)
    print(X_train.shape, y_train.shape, X_test.shape, y_test.shape)
    print(X_train)

    # Returns input function that would feed Pandas DataFrame into the model.
    input_func = tf.estimator.inputs.pandas_input_fn(x=X_train, y=y_train, batch_size=128, num_epochs=1000,
                                                     shuffle=True)

    # Train a linear model to classify instances into one of multiple possible classes.
    # When number of possible classes is 2, this is binary classification.
    # The optimizers are used for improving speed and performance for training a specific model.
    # The main feature of ftrloptimizer is to keep near zero weights at zero, so calculations can be skipped and optimized.
    # Regularization is a technique used to avoid overfitting.
    # Regularization allows for you to control your modelâ€™s complexity and makes the model more generalizable to unseen data.
    model = tf.estimator.LinearClassifier(feature_columns=feat_cols,
                                          n_classes=2,
                                          model_dir="cdiabetes",
                                          optimizer=tf.train.FtrlOptimizer(learning_rate=0.1,
                                                                           l1_regularization_strength=0.001))

    # Train the model
    model.train(input_fn=input_func, steps=20000)

    # Input function to evaluate  the model using test data
    eval_input_func = tf.estimator.inputs.pandas_input_fn(
        x=X_test,
        y=y_test,
        batch_size=128,
        num_epochs=1,
        shuffle=False)

    # Evaluation
    results = model.evaluate(eval_input_func)
    print(results)

    # Retrieving form data

    # Retrieving the age
    age = request.form['age']

    # Retrieving the blood sugar in fasting
    bsf = request.form['bsf']

    # Retrieving the blood sugar after 2-8 hours of meal
    bsaf = request.form['bsaf']

    # Retrieving the Plasma Glucose at random
    prand = request.form['prand']

    # Retrieving the Plasma Glucose in fasting
    pfast = request.form['pfast']

    # Retrieving the Haemoglobin
    haem = request.form['haemo']

    # Copy the form data in CSV file
    with open('predict1.csv', mode='w') as predict_file:
        employee_writer = csv.writer(predict_file, delimiter=',')
        employee_writer.writerow([age,bsf,bsaf,prand,pfast,haem])

    # Read the form data present in predict.csv file
    pred = pd.read_csv("predict1.csv", skipinitialspace=True, names=columns, nrows=1)

    # Input function for prediction
    pred_input_func = tf.estimator.inputs.pandas_input_fn(
      x=pred,
      batch_size=10,
      num_epochs=1,
      shuffle=False)

    # Predictions
    predictions = model.predict(pred_input_func)
    final = []

    # Fetching the class_ids object in generator generated by predictions and append it in final list
    for key in predictions:
        final.append(key['class_ids'][0])
        print(key)

    # if final is zero then has no diabetes else has diabetes
    if final[0] == 0:
        #  Provides feedback to a user about the interaction.
        flash('You have no Diabetes')
        return redirect(url_for('index'))
    else:
        flash('You have Diabetes')
        return redirect(url_for('index'))


if __name__ == "__main__":
    app.run(host='0.0.0.0')
